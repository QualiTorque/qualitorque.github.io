"use strict";(self.webpackChunktorque=self.webpackChunktorque||[]).push([["4106"],{5039:function(e,n,i){i.r(n),i.d(n,{frontMatter:()=>a,toc:()=>u,default:()=>d,metadata:()=>t,assets:()=>o,contentTitle:()=>l});var t=JSON.parse('{"id":"blueprint-designer-guide/blueprints/blueprint-grain","title":"The Blueprint Grain","description":"Reusable building-blocks","source":"@site/docs/blueprint-designer-guide/blueprints/blueprint-grain.md","sourceDirName":"blueprint-designer-guide/blueprints","slug":"/blueprint-designer-guide/blueprints/blueprint-grain","permalink":"/blueprint-designer-guide/blueprints/blueprint-grain","draft":false,"unlisted":false,"editUrl":"https://github.com/QualiTorque/torque-docs/tree/master/docs/blueprint-designer-guide/blueprints/blueprint-grain.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"The Blueprint Grain"},"sidebar":"defaultSidebar","previous":{"title":"The ArgoCD Grain","permalink":"/blueprint-designer-guide/blueprints/argocd-grain"},"next":{"title":"The CDK Grain","permalink":"/blueprint-designer-guide/blueprints/cdk-grain"}}'),r=i(4848),s=i(4429);let a={sidebar_position:7,title:"The Blueprint Grain"},l=void 0,o={},u=[{value:"Reusable building-blocks",id:"reusable-building-blocks",level:2},{value:"Usage example",id:"usage-example",level:2},{value:"Grain Spec Reference",id:"grain-spec-reference",level:2},{value:"<code>source</code>",id:"source",level:3},{value:"<code>agent</code>",id:"agent",level:3},{value:"<code>inputs</code>",id:"inputs",level:3},{value:"<code>outputs</code>",id:"outputs",level:3}];function p(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"reusable-building-blocks",children:"Reusable building-blocks"}),"\n",(0,r.jsx)(n.p,{children:'The Blueprint grain is Torque\u2019s built-in support for allowing a Torque blueprint to be used as a grain in another Torque blueprint. This process is called "nesting" and such a blueprint will then be referred to as a "nested blueprint" within the context of the blueprint in which it is used as a grain. The blueprint containing the blueprint grain is called the \u201Cnesting blueprint\u201D.'}),"\n",(0,r.jsx)(n.p,{children:"Nesting a blueprint allows you to carry over (in a single grain) all of the nested blueprint\u2019s grains, internal dependencies, and orchestration relationships, while only needing to provide the inputs for the nested blueprint, and specify the outputs expected to be received from it. These outputs can then be referred to by other grains in the blueprint."}),"\n",(0,r.jsx)(n.h2,{id:"usage-example",children:"Usage example"}),"\n",(0,r.jsx)(n.p,{children:"Below is an example of a grains section of a nesting blueprint, containing a blueprint grain and a helm grain that depends on it:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\n\ninputs:\n  db_size:\n    type: string\n    allowed-values:\n    - Small\n    - Medium\n    - Large\n    description: |\n      Small: 20 GiB to 100 GiB (suitable for lightweight applications or testing)\n      Medium: 100 GiB to 1 TiB (common for moderate workloads or production databases)\n      Large: 1 TiB to 64 TiB (designed for high-performance, data-intensive applications)\n  \n  db_engine_version:\n    type: string\n    - \"PostgreSQL 16.3\"\n    - \"PostgreSQL 15.7\"\n    - \"PostgreSQL 14.12\"\n\n  version:\n    type: string\n    default: \"1.0.0\"\n\ngrains:\n  infra:\n    kind: blueprint\n    spec:\n      source: \n        store: assets\n        path: blueprints/aws-infra-blueprint.yaml\n      inputs:\n        - size: '{{ .inputs.db_size }}'\n        - engine_version: '{{ .inputs.db_engine_version }}'\n      outputs:\n        - db_hostname\n        - connection_string\n        - s3_bucket_arn\n\n  k8s-app:\n    kind: helm\n    depends-on: infra\n    spec:\n      source:\n        store: assets\n        path: assets/helm-app\n      agent:\n        name: '{{ .inputs.agent }}'\n      inputs:\n        - domain: 'torque-demo.click'\n        - redis.storageClassName: gp2\n        - hostname: 'app--{{ sandboxid | downcase }}'\n        - version: '{{ .inputs.version }}'\n        - connectionString: '{{ .grains.infra.outputs.connection_string }}'\n        - objectStore.s3BucketArn: '{{ .grains.infra.outputs.s3_bucket_arn }}'\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"grain-spec-reference",children:"Grain Spec Reference"}),"\n",(0,r.jsx)(n.h3,{id:"source",children:(0,r.jsx)(n.code,{children:"source"})}),"\n",(0,r.jsxs)(n.p,{children:["The source section of a blueprint grain must contain the ",(0,r.jsx)(n.code,{children:"store"})," and ",(0,r.jsx)(n.code,{children:"path"})," attributes."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"store"}),": Defines the name of the git repository containing the blueprint"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"path"}),": Is set to the references blueprint"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"grains:\n  nginx:\n    kind: blueprint\n    spec:\n      source:\n        store: blueprint-repository\n        path: blueprints\\nginx-blueprint.yaml      \n"})}),"\n",(0,r.jsxs)(n.p,{children:["Please see ",(0,r.jsx)(n.a,{href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#source",children:"the grain source"})," for more details."]}),"\n",(0,r.jsx)(n.h3,{id:"agent",children:(0,r.jsx)(n.code,{children:"agent"})}),"\n",(0,r.jsxs)(n.p,{children:["The blueprint grain does not require an agent as Torque uses the agent defined in the referenced blueprint. However, you can specify the agent as an input of ",(0,r.jsx)(n.code,{children:"type: agent"})," on the blueprint level, and reference it from the grain, both as an input and in the host section."]}),"\n",(0,r.jsx)(n.h3,{id:"inputs",children:(0,r.jsx)(n.code,{children:"inputs"})}),"\n",(0,r.jsxs)(n.p,{children:["Blueprint grain inputs are the names of the inputs of the nested blueprint, and the values being provided for each one when the blueprint is launched as a nested blueprint. These names must exactly match the input names in the ",(0,r.jsx)(n.code,{children:"inputs"})," section of the nested blueprint\u2019s blueprint YAML."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"grains:\n  nginx:\n    kind: blueprint\n    spec:\n      source:\n        ...\n      inputs:\n        - instance_id: '{{ .inputs.instance_id }}'\n        - application_port: '{{ .inputs.application_port }}'\n"})}),"\n",(0,r.jsx)(n.h3,{id:"outputs",children:(0,r.jsx)(n.code,{children:"outputs"})}),"\n",(0,r.jsxs)(n.p,{children:["Blueprint grain outputs are the names of the outputs of the nested blueprint, which will determine which outputs will be populated on the blueprint grain to be later referenced by other grains or by the nesting blueprint\u2019s ",(0,r.jsx)(n.code,{children:"outputs"})," section. These names must exactly match the input names in the ",(0,r.jsx)(n.code,{children:"outputs"})," section of the nested blueprint\u2019s blueprint YAML."]})]})}function d(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},4429:function(e,n,i){i.d(n,{R:()=>a,x:()=>l});var t=i(6540);let r={},s=t.createContext(r);function a(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);