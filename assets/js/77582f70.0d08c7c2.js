"use strict";(self.webpackChunktorque=self.webpackChunktorque||[]).push([["1576"],{584:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>a,toc:()=>c,default:()=>h,metadata:()=>s,assets:()=>l,contentTitle:()=>o});var s=JSON.parse('{"id":"blueprint-designer-guide/blueprints/terraform-grain","title":"The Terraform Grain","description":"The Terraform grain is Torque\'s native support for HashiCorp Terraform modules. Torque allows designers to use Terraform-specific features to easily orchestrate self-developer and community Terraform modules in a standard way and share them with others as building blocks.","source":"@site/docs/blueprint-designer-guide/blueprints/terraform-grain.md","sourceDirName":"blueprint-designer-guide/blueprints","slug":"/blueprint-designer-guide/blueprints/terraform-grain","permalink":"/blueprint-designer-guide/blueprints/terraform-grain","draft":false,"unlisted":false,"editUrl":"https://github.com/QualiTorque/torque-docs/tree/master/docs/blueprint-designer-guide/blueprints/terraform-grain.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"sidebar_position":14,"title":"The Terraform Grain"},"sidebar":"defaultSidebar","previous":{"title":"The OpenTofu Grain","permalink":"/blueprint-designer-guide/blueprints/opentofu-grain"},"next":{"title":"The Terragrunt Grain","permalink":"/blueprint-designer-guide/blueprints/terragrunt-grain"}}'),t=r(4848),i=r(4429);let a={sidebar_position:14,title:"The Terraform Grain"},o=void 0,l={},c=[{value:"Tools and Technologies",id:"tools-and-technologies",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Simple",id:"simple",level:3},{value:"Authentication and Backend",id:"authentication-and-backend",level:3},{value:"Grain Spec Reference",id:"grain-spec-reference",level:2},{value:"<code>source</code>",id:"source",level:3},{value:"<code>agent</code>",id:"agent",level:3},{value:"Storage Configuration",id:"storage-configuration",level:4},{value:"<code>authentication</code>",id:"authentication",level:3},{value:"<code>provider-overrides</code>",id:"provider-overrides",level:3},{value:"<code>backend</code>",id:"backend",level:3},{value:"s3",id:"s3",level:4},{value:"azurerm",id:"azurerm",level:4},{value:"gcs",id:"gcs",level:4},{value:"http",id:"http",level:4},{value:"remote",id:"remote",level:4},{value:"<code>version</code>",id:"version",level:3},{value:"<code>inputs</code>",id:"inputs",level:3},{value:"<code>tfvars files</code>",id:"tfvars-files",level:3},{value:"<code>tags</code>",id:"tags",level:3},{value:"<code>outputs</code>",id:"outputs",level:3},{value:"<code>scripts</code>",id:"scripts",level:3},{value:"<code>auto-approve</code>",id:"auto-approve",level:3},{value:"<code>env-vars</code>",id:"env-vars",level:3},{value:"<code>target-resource</code>",id:"target-resource",level:3}];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The Terraform grain is Torque's native support for HashiCorp Terraform modules. Torque allows designers to use Terraform-specific features to easily orchestrate self-developer and community Terraform modules in a standard way and share them with others as building blocks."}),"\n",(0,t.jsxs)(n.p,{children:["Note that to deploy Terraform modules, you will need to authenticate Terraform on the Kubernetes cluster. For details, see ",(0,t.jsx)(n.a,{href:"/torque-agent/service-accounts-for-aws",children:"Terraform EKS Authentication"}),", ",(0,t.jsx)(n.a,{href:"/torque-agent/service-accounts-for-azure",children:"Terraform AKS Authentication"}),", or ",(0,t.jsx)(n.a,{href:"/torque-agent/service-accounts-for-gcp",children:"Terraform GKE Authentication"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"tools-and-technologies",children:"Tools and Technologies"}),"\n",(0,t.jsx)(n.p,{children:"The following tools and technologies are installed out of the box on our agents in the Kubernetes pods and can be used when writing grain scripts (pre/post, etc.):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"dotnet"}),"\n",(0,t.jsx)(n.li,{children:"terraform"}),"\n",(0,t.jsx)(n.li,{children:"git"}),"\n",(0,t.jsx)(n.li,{children:"python3"}),"\n",(0,t.jsx)(n.li,{children:"pip3"}),"\n",(0,t.jsx)(n.li,{children:"jq"}),"\n",(0,t.jsx)(n.li,{children:"docker-compose"}),"\n",(0,t.jsx)(n.li,{children:"curl"}),"\n",(0,t.jsx)(n.li,{children:"hcl2json"}),"\n",(0,t.jsx)(n.li,{children:"awscli"}),"\n",(0,t.jsx)(n.li,{children:"kubectl"}),"\n",(0,t.jsx)(n.li,{children:"helm"}),"\n",(0,t.jsx)(n.li,{children:"opa"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.h3,{id:"simple",children:"Simple"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\ndescription: Deploy an S3 bucket using Terraform\n\ninputs:\n  agent:\n    type: agent\n  bucket_name:\n    type: string\n    default: \"my-torque-bucket\"\n\ngrains:\n  s3_bucket:\n    kind: terraform\n    spec:\n      source:\n        store: terraform-repo\n        path: aws/s3\n      agent:\n        name: '{{ .inputs.agent }}'\n      inputs:\n        - bucket_name: '{{ .inputs.bucket_name }}-{{ envId | downcase }}'\n      outputs:\n        - bucket_id\n        - bucket_arn\n"})}),"\n",(0,t.jsx)(n.h3,{id:"authentication-and-backend",children:"Authentication and Backend"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'spec_version: 2\ndescription: Deploy RDS instance with custom authentication and remote state\n\ninputs:\n  agent:\n    type: agent\n  db_size:\n    type: string\n    default: "20"\n  environment:\n    type: string\n    default: "dev"\n\ngrains:\n  database:\n    kind: terraform\n    spec:\n      version: 1.5.5\n      source:\n        store: infra-repo\n        path: terraform/rds\n      agent:\n        name: \'{{ .inputs.agent }}\'\n      authentication:\n        - aws-credentials\n      backend:\n        type: "s3"\n        bucket: "terraform-state-bucket"\n        region: "us-east-1"\n        key-prefix: "torque/databases"\n      inputs:\n        - database_size: \'{{ .inputs.db_size }}\'\n        - environment: \'{{ .inputs.environment }}\'\n      outputs:\n        - database_endpoint\n        - database_port\n'})}),"\n",(0,t.jsx)(n.h2,{id:"grain-spec-reference",children:"Grain Spec Reference"}),"\n",(0,t.jsx)(n.h3,{id:"source",children:(0,t.jsx)(n.code,{children:"source"})}),"\n",(0,t.jsxs)(n.p,{children:["Please see ",(0,t.jsx)(n.a,{href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#source",children:"the grain source"})," for more details."]}),"\n",(0,t.jsx)(n.h3,{id:"agent",children:(0,t.jsx)(n.code,{children:"agent"})}),"\n",(0,t.jsxs)(n.p,{children:["Please see ",(0,t.jsx)(n.a,{href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#agent",children:"the grain agent"})," for more details."]}),"\n",(0,t.jsx)(n.h4,{id:"storage-configuration",children:"Storage Configuration"}),"\n",(0,t.jsx)(n.p,{children:"By default, Terraform runners mount storage to store the state (when no backend is specified in the blueprint or in the Terraform configuration) and for code caching optimization. This storage helps improve performance by caching downloaded modules and providers between runs."}),"\n",(0,t.jsxs)(n.p,{children:["In case a complete stateless mode is desired, you can specify the ",(0,t.jsx)(n.code,{children:"use-storage: false"})," flag under the agent section to run without storage:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  rds:\n    kind: terraform\n    spec:\n      source: ..\n      backend: ..\n      agent:        \n        name: '{{ .inputs.agent }}'\n        use-storage: false\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"use-storage: false"})," is specified, ensure you have a remote backend configured to store the Terraform state, as local state will not be persisted between runs."]})}),"\n",(0,t.jsx)(n.h3,{id:"authentication",children:(0,t.jsx)(n.code,{children:"authentication"})}),"\n",(0,t.jsxs)(n.p,{children:["To authenticate with AWS and deploy the terraform module, Torque will try to use the default service account configured for the selected agent. You can also supply different credentials in the grain's ",(0,t.jsx)(n.code,{children:"authentication"})," section. This is done by referencing a ",(0,t.jsx)(n.a,{href:"/admin-guide/credentials",children:"credential"})," that contains these authentication details. There are two ways to specify the credential, literally by name or using an input:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: infra \n        path: terraform/rds\n      authentication:\n        - credential_name or {{.inputs.credentials_input_name}} \n"})}),"\n",(0,t.jsx)(n.h3,{id:"provider-overrides",children:(0,t.jsx)(n.code,{children:"provider-overrides"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"provider-overrides"}),' block allows you to dynamically inject provider blocks with custom attributes to Terraform grains. This is useful when you need to make modules "runnable" or "testable" in different cloud environments.']}),"\n",(0,t.jsxs)(n.p,{children:["To use provider overrides, add a ",(0,t.jsx)(n.code,{children:"provider-overrides"})," block to the Terraform grain spec:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'grains:\n  database:\n    kind: terraform\n    spec:\n      source: ..\n      provider-overrides:\n        - name: aws # in case no provider block is defined in the tf configuration\n          source: hashicorp/aws\n          version: ~>5.0.0 \n          attributes:\n            region: us-east-1\n            assume_role: # the mounted service-account should have permissions to assume role\n              role_arn: "arn:aws:iam::{{ .inputs.target-account }}:role/role-name"\n        - name: aws\n          source: hashicorp/aws\n          version: ~>5.0.0 # Optional \n          attributes:\n            alias: ue2\n            region: us-east-2\n      \n      source: ...\n      agent: ...\n      inputs: ...\n      outputs: ...\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"provider-overrides"})," block is a list where each item has:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name"}),": A unique name for the provider"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"source"}),": The source location for the provider (e.g. ",(0,t.jsx)(n.code,{children:"hashicorp/aws"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"version"})," (optional): The version constraint for the provider"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"attributes"}),": Key/value attributes to set on the provider block"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This will generate the following Terraform code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-hcl",children:'terraform {\n  required_providers {\n    aws = {\n      source = "hashicorp/aws"\n      version = "~>5.0.0" \n    }   \n  }\n}\n\nprovider {\n "aws": [{\n    region = "us-east-1"\n    assume_role {\n      role_arn = "arn:aws:iam::{{ .inputs.target-account }}:role/role-name"\n    }\n  },\n  {\n    alias       = "ue2" \n    region      = "us-east-2"\n  }]\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"attributes"})," map allows setting any attributes on the generated provider blocks. Note that there is no schema validation on these attributes."]}),"\n",(0,t.jsxs)(n.p,{children:["Liquid templating is supported in the ",(0,t.jsx)(n.code,{children:"attributes"})," values, allowing blueprint inputs to be referenced like ",(0,t.jsx)(n.code,{children:"{{ .inputs.target-account }}"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"backend",children:(0,t.jsx)(n.code,{children:"backend"})}),"\n",(0,t.jsxs)(n.p,{children:["When launching the environment, Torque creates a tfstate file for each Terraform grain in the blueprint. By default, the state is saved locally on the PVC of the grain runner (volume for Docker agents). However, Torque allows you to optionally choose to save the terraform state in a backend of your choice. Torque supports the following backends: ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/language/settings/backends/s3",children:"S3"})}),", ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/language/settings/backends/gcs",children:"gcs"})}),", ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/language/settings/backends/azurerm",children:"azurerm"})}),", ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/language/settings/backends/http",children:"http"})}),", and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/language/backend/remote",children:"remote"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Prerequisites:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The backend must already exist. Torque will not create the backend if it doesn't exist."}),"\n",(0,t.jsxs)(n.li,{children:["RoleARN in the ",(0,t.jsx)(n.code,{children:"service-account"})," or ",(0,t.jsx)(n.code,{children:"authentication"})," block, must have access permissions to the backend specified."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Based on the ",(0,t.jsx)(n.code,{children:"backend"})," block in the blueprint definition, Torque will create an override file that contains the backend configurations."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'grains:\n  database:\n    kind: terraform\n    spec:\n      ...\n      backend:\n        type: "s3"\n        bucket: "my-bucket-name"\n        region: "us-east-1"\n        key-prefix: "folder1/folder2"\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Properties"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"type"}),": ",(0,t.jsx)(n.code,{children:"s3"}),", ",(0,t.jsx)(n.code,{children:"azurerm"}),", ",(0,t.jsx)(n.code,{children:"gcs"}),", ",(0,t.jsx)(n.code,{children:"http"}),", ",(0,t.jsx)(n.code,{children:"remote"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"bucket"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"s3"})," and ",(0,t.jsx)(n.code,{children:"gcs"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"region"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"s3"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"resource-group-name"})," : Mandatory for ",(0,t.jsx)(n.code,{children:"azurerm"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"storage-account-name"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"azurerm"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"container-name"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"azurerm"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"base-address"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"http"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"organization"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"remote"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workspaces"}),": Mandatory for ",(0,t.jsx)(n.code,{children:"remote"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"key-prefix"}),": Optional. tfstate file path in the backend storage. Relevant for ",(0,t.jsx)(n.code,{children:"s3"}),", ",(0,t.jsx)(n.code,{children:"azurerm"}),", ",(0,t.jsx)(n.code,{children:"gcs"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"s3, Azure Blobs & GCS have a key name limit of 1024 ascii chars"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"s3",children:"s3"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'  backend:\n    type: "s3"\n    bucket: "my-bucket-name"\n    region: "us-east-1"\n    key-prefix: folder1/folder2"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"azurerm",children:"azurerm"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'  backend:\n    type: "azurerm"\n    resource-group-name: "my_rg"\n    storage-account-name: "terraform123abc"\n    container-name: "terraform-state"\n    key-prefix: folder1/folder2"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"gcs",children:"gcs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'  backend:\n    type: "gcs"\n    bucket: "my-bucket-name"\n    key-prefix: "folder1/folder2"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"http",children:"http"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'  backend:\n    type: "http"\n    base-address: "http://myrest.api.com/foo"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"remote",children:"remote"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"  backend:\n    type: 'remote'\n    hostname: 'app.terraform.io'\n    token: '{{ params.my_token }}'\n    organization: 'my_org'\n    workspaces:\n      - name: 'my_workspace' # IMPORTANT: only one (name or prefix) is needed in each workspace element\n        prefix: 'my_prefix'\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"remote"})," token options:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Using the ",(0,t.jsx)(n.code,{children:"token"})," field in the ",(0,t.jsx)(n.code,{children:"remote"})," backend definition is best practice."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"TF_TOKEN"})," ",(0,t.jsx)(n.code,{children:"env_var"}),", followed by the hostname (with replace of '.' in '_') is an alternative way to provide a token.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For example for the host 'app.terraform.io', the env-var name should be ",(0,t.jsx)(n.code,{children:"TF_TOKEN_app_terraform_io"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.p,{children:'Torque uses a "1 to many" model, meaning that one blueprint definition is used to launch many standalone environments. When using a backend for Terraform grains, it is important to ensure that each live instance of the grain has its own unique tfstate file, so Torque will auto-generate the tfstate file name.'}),(0,t.jsx)(n.p,{children:"For s3, gcs, azurerm backends, the tfstate file location will be:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The format when the ",(0,t.jsx)(n.code,{children:"key-prefix"})," is not defined in the blueprint:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"torque-remote-state/{environmentId}_{grainName}.tfstate\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The format when ",(0,t.jsx)(n.code,{children:"key-prefix"})," is defined in the blueprint:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Using the optional \u201Ckey-prefix\u201D property the blueprint designer can choose the folder where the tfstate file will be located."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"{key-prefix}/{environmentId}_{grainName}.tfstate\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"http"})," backend the tfstate file address will be:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"{base-address}/{environmentId}_{grainName}\n"})}),"\n"]}),"\n"]}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Cleaning up the tfstate file when the Terraform grain is destroyed:"})}),(0,t.jsx)(n.p,{children:"When destroying a Terraform environment, Terraform does not delete the tfstate file but rather leaves behind an empty file. To clean up the leftovers, set a file retention policy on the remote storage to ensure the removal of files that have not been recently accessed. Since Torque runs drift detection on a 1-hour schedule, the tfstate file will be considered as \u201Caccessed\u201D by the remote storage when running drift detection. And when the Torque environment ends, the tfstate file will not be \u201Caccessed\u201D anymore by Torque."})]}),"\n",(0,t.jsx)(n.h3,{id:"version",children:(0,t.jsx)(n.code,{children:"version"})}),"\n",(0,t.jsxs)(n.p,{children:["Torque provides the flexibility to choose a specific Terraform version with which the Terraform module will be deployed (minimum supported version is 0.14, last version supported is 1.5.5). Otherwise, you can use the ",(0,t.jsx)(n.a,{href:"/blueprint-designer-guide/blueprints/custom-grain",children:"custom-grain option"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  hello_world:\n    kind: terraform\n    spec:\n      version: 1.5.5\n      source:\n        store: terraform\n        path: hello\n      ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"inputs",children:(0,t.jsx)(n.code,{children:"inputs"})}),"\n",(0,t.jsx)(n.p,{children:"Similar to blueprint inputs, the Terraform grain input allows you to reuse the same Terraform module in different ways. Inputs provided to the Terraform grain are used when launching the Terraform module. Terraform grain inputs should be listed in the order defined in the module's variables.tf file. We recommend using Torque's auto-discovery capability to quickly model your Terraform modules within Torque including all defined inputs."}),"\n",(0,t.jsxs)(n.p,{children:["Every value that goes to the Terraform grain's input is interpreted as a json token. So you can pass any valid value by json: number, list, dictionary, boolean, string , etc.\nFor details, check out this Terraform Docs section ",(0,t.jsx)(n.a,{href:"https://www.terraform.io/language/values/variables#variable-definitions-tfvars-files",children:"Variable Definitions (.tfvars) Files"})]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: infra \n        path: terraform/rds\n      authentication:\n        - ...        \n      ...\n      inputs:\n        - database_size: \'{{ .inputs.db_size }}\' \n        - database_name: \'{{ .inputs.db_name }}\' \n        - input_number: 6\n        - input_string: \'{" this is my input string "}\'\n        - input_list_strings: \'["a","b","c"]\'\n        - input_map_strings: \'{ "key1":"val1", "key2":"val2" }\'\n        - input_object: \'{ "key1":val1, "key2":4 }\'\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:'Note that in the above example, some blueprint inputs are used as the values of the Terraform grain inputs, so the environment\'s owner is able to choose the db_size and db_name required for his need. The information provided by the user will be passed to Terraform and affect the deployment process. The blueprint input type is always "string". the actual parsing of the json type will be done automatically.'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that invalid tokens will be parsed as strings. Keep in mind that json strings require double quotes, so ",(0,t.jsx)(n.code,{children:'"my value'})," is a string but ",(0,t.jsx)(n.code,{children:"my value"})," is not a valid json value and therefore will also be passed as a string. As such, the following values will all be passed as strings: ",(0,t.jsx)(n.code,{children:'"my value"'}),", ",(0,t.jsx)(n.code,{children:"my value"}),", ",(0,t.jsx)(n.code,{children:'"[1,2,3]"'})]}),"\n",(0,t.jsx)(n.h3,{id:"tfvars-files",children:(0,t.jsx)(n.code,{children:"tfvars files"})}),"\n",(0,t.jsx)(n.p,{children:'In Terraform, a tfvars file (short for "Terraform variables file") is a plain text file that contains a set of key-value pairs representing values for Terraform variables. Torque supports referencing tfvars files as inputs to the terraform grain, with the following syntax:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: infra \n        path: terraform/rds\n      authentication:\n        - ...        \n      ...\n      inputs:\n        ...\n      tfvars-files:\n      - source:\n          store: <> \n          path: <>\n      - source:\n          store: <>\n          path: <>\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tags",children:(0,t.jsx)(n.code,{children:"tags"})}),"\n",(0,t.jsxs)(n.p,{children:["Whenever a Terraform grain is launched, all resources created during the deployment process will be automatically tagged with Torque's system tags, built-in tags and custom tags. For details, see ",(0,t.jsx)(n.a,{href:"/governance/tags",children:"Tags"}),".\nSometimes, you need to disable tagging for all or specific resources.\nTo disable ",(0,t.jsx)(n.em,{children:"all"})," resources in a specific grain use the following syntax:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  database:\n    kind: terraform\n    spec:\n      tags:\n        auto-tag: false\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To disable ",(0,t.jsx)(n.em,{children:"specific"})," resources in a specific grain use the following syntax:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  database:\n    kind: terraform\n    spec:\n      tags:\n        disable-tags-for:\n        - aws_s3_bucket_object ## the terraform resource type\n"})}),"\n",(0,t.jsx)(n.h3,{id:"outputs",children:(0,t.jsx)(n.code,{children:"outputs"})}),"\n",(0,t.jsx)(n.p,{children:"Output are values generated by Terraform during the deployment process. Outputs should be defined in the outputs.tf file located in the Terraform module folder. We recommend using Torque's auto-discovery capability to quickly model your Terraform modules within Torque including it's defined outputs."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: my-repo \n        path: my-asset     \n      ...\n      outputs:\n        - agent_name\n        - connection_string\n"})}),"\n",(0,t.jsx)(n.h3,{id:"scripts",children:(0,t.jsx)(n.code,{children:"scripts"})}),"\n",(0,t.jsx)(n.p,{children:"Torque provides the ability to execute custom code before the executing the Terraform module init and before the Terraform destroy process. Scripts allows to run CLI commands to make sure authentication and requirements are set prior to the Terraform execution at the environment's initialization and destroy process."}),"\n",(0,t.jsx)(n.p,{children:"The available script hooks are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["pre-tf-init: The script will run before the command ",(0,t.jsx)(n.code,{children:"terraform init"})]}),"\n",(0,t.jsxs)(n.li,{children:["post-tf-plan: The script will run after the command ",(0,t.jsx)(n.code,{children:"terraform plan"})]}),"\n",(0,t.jsxs)(n.li,{children:["pre-tf-destroy: The script will run before the command ",(0,t.jsx)(n.code,{children:"terraform destroy"}),"\nIn the below example, authentication script is used to assume role to another AWS account prior to deploying workload into that account."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  amazon_emr:\n    kind: terraform\n    spec:\n    ...\n      source:\n        store: tf-repo\n        path: .\n      authentication:\n        - aws-auth        \n      scripts: \n        pre-tf-init:\n          source:\n            store: tf-repo\n            path : scripts/authenticate.sh\n          arguments: '{{.inputs.ACCOUNT_ID}}'\n        post-tf-plan:\n          source:\n            store: tf-repo\n            path : scripts/verify-plan.sh\n          arguments: '{{.inputs.ID2}'          \n        pre-tf-destroy:\n          source:\n            store: tf-repo\n            path : scripts/authenticate.sh\n          arguments: \"{{.inputs.ACCOUNT_ID}} {{.inputs.ID2}} 3\"\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"Note that scripts should be stored next to your IaC code to be used under the scripts section."})}),"\n",(0,t.jsx)(n.p,{children:"When writing the scripts, you can take advantage of the following out of the box environment variables provided by Torque:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TORQUE_TF_EXECUTABLE"})," - the terraform executable file name"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TORQUE_TF_MODULE_PATH"})," - the path to the terraform executable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TORQUE_TF_PLAN_PATH"})," - path to the results of the terraform plan command. This is very useful to be used in a post-tf-plan script for verification of the plan."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TORQUE_TF_PLAN_JSON_PATH"})," - path to the results of the terraform plan command in json format."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example, the script can contain the following :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$TORQUE_TF_EXECUTABLE -chdir=$TORQUE_TF_MODULE_PATH state rm $1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$TORQUE_TF_EXECUTABLE -chdir=$TORQUE_TF_MODULE_PATH state rm <hard_coded_resource>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Here is another example which shows how to use the plan output in a post-tf-plan script:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'## validate-no-new-resources.sh\n\nif grep -q \'Plan: [1-9][0-9]* to add, 0 to change, 0 to destroy\' "$TORQUE_TF_PLAN_JSON_PATH"; then\n  echo "Error: The plan indicates new resources"\n  exit 1\nelse\n  echo "Success: No new resources added."\n  exit 0\nfi\n'})}),"\n",(0,t.jsx)(n.h3,{id:"auto-approve",children:(0,t.jsx)(n.code,{children:"auto-approve"})}),"\n",(0,t.jsx)(n.p,{children:'The "auto-approve" flag in Terraform is used to automatically approve and apply changes without requiring manual confirmation. It is helpful in automation workflows or scripts where user interaction is not feasible, allowing for unattended execution of Terraform commands without the need for explicit approval during the apply phase. By default, Torque will apply the terraform module with auto-approval.\nHowever, you might specifically want to ensure that critical or potentially destructive changes are reviewed and approved by a user before being applied. This adds an extra layer of safety, especially in scenarios where unintended consequences could result from applying infrastructure changes. It provides an opportunity to carefully inspect the proposed changes before confirming their execution.\nTo do that, you can set the auto-approve flag in the terraform grain spec to false (default will be true):'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  my-tf-grain:\n    kind: terraform\n    spec:\n    ...\n      auto-approve: false\n"})}),"\n",(0,t.jsx)(n.h3,{id:"env-vars",children:(0,t.jsx)(n.code,{children:"env-vars"})}),"\n",(0,t.jsx)(n.p,{children:"The environment variables declared in the terraform grain will be available during the grain deployment as well as the grain destroy phase."}),"\n",(0,t.jsxs)(n.p,{children:["In this example, terraform is using a backend of type ",(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/language/settings/backends/remote",children:"remote"})," with a custom host that requires a custom certificate."]}),"\n",(0,t.jsxs)(n.p,{children:["You can mount the Terraform Runner, a Kubernetes secret containing the certificate file(s) to a directory in the container, and the certificate(s) will be available for use ",(0,t.jsx)(n.strong,{children:"without"}),' running any additional commands (like "sudo update-ca-certificates")']}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["*Learn how to mount secrets to a runner - ",(0,t.jsx)(n.a,{href:"/torque-agent/advanced-settings#secret-mount",children:"Agent Advanced Settings"})," *"]})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Environment variables usage example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\ndescription: Passing environment variables to Terraform and using scripts before tf-init\n\ninputs: ...\noutputs: ...\n\ngrains:\n  provision-s3-bucket:\n    kind: terraform\n    spec:  \n      source:\n        store: terraform-mono-repo\n        path: aws/s3-bucket\n      scripts:\n        pre-tf-init: \n          source:\n            store: scripts-repo\n            path : scripts/gen-custom-remote-backend.sh\n          arguments: '{{ .inputs.org }} {{ .inputs.workspace }}'\n      agent: ...\n      inputs: ...\n      outputs: ...\n      \n      # The environment variables declared in this section will be available \n      #  during the grain deployment as well as the grain destroy phase\n      env-vars: \n        - SSL_CERT_FILE: /etc/tls-certs/custom-cert.crt # This is a custom SSL cert file\n        - CUSTOM_TOKEN: '{{ .params.token }}'\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"target-resource",children:(0,t.jsx)(n.code,{children:"target-resource"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"target-resource"})," block allows you to specify specific Terraform resources or modules to target during the deployment or destruction process."]}),"\n",(0,t.jsx)(n.p,{children:"This is particularly useful when you want to apply changes or destroy only a subset of resources without affecting the entire Terraform configuration."}),"\n",(0,t.jsxs)(n.p,{children:["To use resource targeting, add a ",(0,t.jsx)(n.code,{children:"target-resource"})," block to the Terraform grain spec:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  s3:\n    kind: terraform\n    spec:\n      target-resource: \n        - module.s3_bucket\n        - {{ .inputs.tf_resource }}\n      source:\n        store: assets-repo\n        path: terraform/s3\n      agent:\n        name: '{{ .inputs.agent }}'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Each item in the ",(0,t.jsx)(n.code,{children:"target-resource"})," list represents a specific resource or module to target. You can use static values or dynamic inputs (e.g., ",(0,t.jsx)(n.code,{children:"{{ .inputs.tf_resource }}"}),") to define the resources."]}),"\n",(0,t.jsxs)(n.p,{children:["For more details on resource targeting, see the ",(0,t.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/tutorials/state/resource-targeting",children:"Terraform documentation"}),"."]})]})}function h(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},4429:function(e,n,r){r.d(n,{R:()=>a,x:()=>o});var s=r(6540);let t={},i=s.createContext(t);function a(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);