"use strict";(self.webpackChunktorque=self.webpackChunktorque||[]).push([["3184"],{8591:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>r,toc:()=>c,default:()=>h,metadata:()=>i,assets:()=>l,contentTitle:()=>o});var i=JSON.parse('{"id":"blueprint-designer-guide/blueprints/ansible-grain","title":"The Ansible Grain","description":"The Ansible grain is Torque\u2019s native support for orchestrating the execution of Ansible playbooks as part of a Torque blueprint. The referenced playbook can rely on vars or inventory-hosts that are dynamically provided by Torque, and then utilize them to perform configuration management, updates, a health check or any other flow that is executable from Ansible.","source":"@site/docs/blueprint-designer-guide/blueprints/ansible-grain.md","sourceDirName":"blueprint-designer-guide/blueprints","slug":"/blueprint-designer-guide/blueprints/ansible-grain","permalink":"/blueprint-designer-guide/blueprints/ansible-grain","draft":false,"unlisted":false,"editUrl":"https://github.com/QualiTorque/torque-docs/tree/master/docs/blueprint-designer-guide/blueprints/ansible-grain.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"The Ansible Grain"},"sidebar":"torqueSidebar","previous":{"title":"Blueprint YAML Structure","permalink":"/blueprint-designer-guide/blueprints/blueprints-yaml-structure"},"next":{"title":"The ArgoCD Grain","permalink":"/blueprint-designer-guide/blueprints/argocd-grain"}}'),t=s(4848),a=s(4429);let r={sidebar_position:5,title:"The Ansible Grain"},o=void 0,l={},c=[{value:"Tools and technologies",id:"tools-and-technologies",level:2},{value:"Ansible discovery",id:"ansible-discovery",level:2},{value:"Installing Ansible Requirements",id:"installing-ansible-requirements",level:2},{value:"Usage example",id:"usage-example",level:2},{value:"Grain Spec Reference",id:"grain-spec-reference",level:2},{value:"<code>source</code>",id:"source",level:3},{value:"<code>agent</code>",id:"agent",level:3},{value:"<code>inputs</code>",id:"inputs",level:3},{value:"<code>inventory-file</code>",id:"inventory-file",level:3},{value:"<code>outputs</code>",id:"outputs",level:3},{value:"<code>command-arguments</code>",id:"command-arguments",level:3},{value:"<code>scripts</code>",id:"scripts",level:3},{value:"Use Case: Creating a Vault Password File",id:"use-case-creating-a-vault-password-file",level:4},{value:"Script Execution Environment",id:"script-execution-environment",level:4},{value:"Additional Notes",id:"additional-notes",level:4},{value:"<code>on-destroy</code>",id:"on-destroy",level:3},{value:"Motivation",id:"motivation",level:4},{value:"Usage Example",id:"usage-example-1",level:4},{value:"Explanation of the Example",id:"explanation-of-the-example",level:4},{value:"Notes",id:"notes",level:4}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The Ansible grain is Torque\u2019s native support for orchestrating the execution of Ansible playbooks as part of a Torque blueprint. The referenced playbook can rely on vars or inventory-hosts that are dynamically provided by Torque, and then utilize them to perform configuration management, updates, a health check or any other flow that is executable from Ansible."}),"\n",(0,t.jsx)(n.h2,{id:"tools-and-technologies",children:"Tools and technologies"}),"\n",(0,t.jsx)(n.p,{children:"The following tools and technologies are installed out of the box on our agents in the Kubernetes pods and can be used when designing ansible playbook execution:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"dotnet"}),"\n",(0,t.jsx)(n.li,{children:"git"}),"\n",(0,t.jsx)(n.li,{children:"python3"}),"\n",(0,t.jsx)(n.li,{children:"pip3"}),"\n",(0,t.jsx)(n.li,{children:"ansible"}),"\n",(0,t.jsx)(n.li,{children:"openssh-client"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ansible-discovery",children:"Ansible discovery"}),"\n",(0,t.jsxs)(n.p,{children:["Auto-discovery of Ansible playbooks requires parsing the file content to differentiate playbooks from other YAML files. The validation process checks if a ",(0,t.jsx)(n.code,{children:"yaml"})," file contains the ",(0,t.jsx)(n.code,{children:"tasks"})," property, which is a key indicator of an Ansible playbook."]}),"\n",(0,t.jsx)(n.p,{children:"The process is optimized to ensure efficient and targeted scanning."}),"\n",(0,t.jsx)(n.p,{children:"The structure of a playbook directory should be as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"base_folder/\n  vars/ # any directory name\n    variables_file # any filename without extension\n  playbook.yaml\n"})}),"\n",(0,t.jsx)(n.p,{children:"A variables file might have the following structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'variable1: test\nvariable2:\n  - value1\n  - value2\n  - value3\nvariable3:\n  test: "value1"\n  test2: "value2"\n  test3: \'{{ name }}\'\n'})}),"\n",(0,t.jsx)(n.p,{children:"Below is an example of an auto-generated blueprint based on a discovered playbook and its variables file. This demonstrates how Torque can help you quickly scaffold a working Ansible blueprint:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\ndescription: Auto-generated Ansible Blueprint\n\ninputs:\n  agent:\n    type: agent\n  variable1:\n    type: string\n    default: test\n  variable2:\n    type: list\n    default: \n      - value1\n      - value2\n      - value3\n  variable3:\n    type: dict\n    default:\n      test: \"value1\"\n      test2: \"value2\"\n      test3: '{{ name }}'\n\ngrains:\n  ansible_playbook:\n    kind: ansible\n    spec:\n      source:\n        store: ansible-repo\n        path: ansible/playbook.yml\n      agent:\n        name: '{{ .inputs.agent }}'\n      inputs:\n        - variable1: '{{ .inputs.variable1 }}'\n        - variable2: '{{ .inputs.variable2 }}'\n        - variable3: '{{ .inputs.variable3 }}'\n      # The outputs section below is a placeholder. Review and update based on your playbook's actual outputs.\n      outputs:\n        - result\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.strong,{children:"Note"})}),(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"outputs"})," section in the auto-generated blueprint is a placeholder. You should review and update it to match the actual outputs produced by your playbook. Since outputs depend on the playbook's content, they cannot be determined automatically during discovery."]})]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.strong,{children:"Note"})}),(0,t.jsxs)(n.p,{children:["Always validate and adjust the generated blueprint YAML before running it, especially the ",(0,t.jsx)(n.code,{children:"outputs"})," section, to ensure it behaves as expected."]})]}),"\n",(0,t.jsx)(n.h2,{id:"installing-ansible-requirements",children:"Installing Ansible Requirements"}),"\n",(0,t.jsxs)(n.p,{children:["Torque is designed to streamline the installation of your module\u2019s dependencies. It accomplishes this by automatically detecting and installing the requirements specified in a ",(0,t.jsx)(n.code,{children:"requirements.yaml"})," or ",(0,t.jsx)(n.code,{children:"requirements.yml"})," file. This file should be located in the root directory of your module."]}),"\n",(0,t.jsxs)(n.p,{children:["For instance, if your module\u2019s main file is located at ",(0,t.jsx)(n.code,{children:"ansible/my-module/main.yaml"}),", the corresponding requirements file should be placed in the same directory, i.e., ",(0,t.jsx)(n.code,{children:"ansible/my-module/"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"By adhering to this structure, you can ensure that Torque correctly identifies and installs all necessary requirements for your module."}),"\n",(0,t.jsx)(n.h2,{id:"usage-example",children:"Usage example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\ndescription: Ansible playbook example with pre-ansible-run scripts\n\ninputs:\n  agent:\n    type: agent\n\ngrains:\n  ansible_playbook:\n    kind: ansible\n    spec:\n      source:\n        store: ansible-repo\n        path: ansible/playbook.yml\n      agent:\n        name: '{{ .inputs.agent }}'\n      command-arguments: \"--vault-password-file ~/.vault_pass.txt\"\n      scripts:\n        pre-ansible-run:\n          source:\n            store: my-script-repo\n            path: scripts/create_vault_file.sh\n          arguments: '{{ .params.vault_pass }}'\n"})}),"\n",(0,t.jsx)(n.h2,{id:"grain-spec-reference",children:"Grain Spec Reference"}),"\n",(0,t.jsx)(n.h3,{id:"source",children:(0,t.jsx)(n.code,{children:"source"})}),"\n",(0,t.jsx)(n.p,{children:"The source section of an Ansible grain provides Torque with the information on where the Ansible playbook is stored and should be retrieved from. This could be either a direct source URL to an Ansible playbook YAML file, or it can be a reference from a Torque-connected git repository."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example - direct:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"ansible-grain:\n  kind: ansible\n  spec:\n    source:\n      path: https://github.com/quali/demo/blob/main/assets/ansible/install_apache2_ubuntu.yaml\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example - repository:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"ansible-grain:\n  kind: ansible\n  spec:\n    source:\n      store: assets\n      path: assets/ansible/install_apache2_webgame_ubuntu.yaml\n"})}),"\n",(0,t.jsx)(n.h3,{id:"agent",children:(0,t.jsx)(n.code,{children:"agent"})}),"\n",(0,t.jsxs)(n.p,{children:["Please see ",(0,t.jsx)(n.a,{href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#agent",children:"the grain agent"})," for more details."]}),"\n",(0,t.jsx)(n.h3,{id:"inputs",children:(0,t.jsx)(n.code,{children:"inputs"})}),"\n",(0,t.jsx)(n.p,{children:'Inputs which are provided to the ansible grain will be used in the ansible command line as "extra-vars".\nThe syntax is similar to any grain inputs.'}),"\n",(0,t.jsx)(n.p,{children:"Let's look at an example. In the example we have a blueprint with 2 grains: a VM and an ansible playbook to configure it."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Blueprint:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\n   ...   \ngrains:\n  my_vm:\n    kind: terraform\n    spec:\n      source:\n        store: assets\n        path: terraform/vcenter/linux_vm\n      outputs:\n      - vm_ip\n      - vm_link\n      - vm_name\n\n  configure-vm:\n    depends-on: my_vm\n    kind: ansible\n    spec:\n      source:\n        store: assets\n        path: assets/ansible/configure.yaml\n      inputs:\n        - nodes: '{{ grains.my_vm.outputs.vm_ip }}'\n        - username: '{{ .params.vc_ubuntu_user }}'\n        - password: '{{ .params.vc_ubuntu_password }}'\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"Torque supports playbooks which use ansible roles."})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Playbook:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- hosts: {{ nodes }}\n  tasks:\n  - name: configure virtual machine\n    azure_rm_virtualmachine:\n      username: "{{ username }}"\n      password: "{{ password }}"\n      \u2026          \n'})}),"\n",(0,t.jsx)(n.p,{children:"Torque will create a JSON file containing the grain inputs under the path: /var/run/ansible/inputs/inputs.json."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "nodes": [...],\n  "username": ...,\n  "password": ...\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The playbook will be executed with the extra vars in the following way:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'ansible-playbook myplaybook.yaml --extra-vars "@/var/run/ansible/inputs/inputs.json"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"inventory-file",children:(0,t.jsx)(n.code,{children:"inventory-file"})}),"\n",(0,t.jsxs)(n.p,{children:["Inventory file is a special grain section unique to the ansible grain, that allows you to provide in a YAML structured format, the content of the Ansible inventory file that will be generated for the Ansible playbook to use. For a deep understanding of the format of this file, please see the Ansible official documentation at ",(0,t.jsx)(n.a,{href:"https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#inventory-basics-formats-hosts-and-groups",children:"https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#inventory-basics-formats-hosts-and-groups"}),".\nThe general standard structure for such a file is as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"host_group:\n  hosts:\n    host1:\n      host1_var: host1_var_value\n    host2:\n      host2_var: host1_var_value\n  vars:\n    group_var: group_var_value\n"})}),"\n",(0,t.jsx)(n.p,{children:"Depending on the Ansible packages used in the playbook, these host and group variables may be used automatically by the package step (in which case, they must be provided in a specific name, for example an \u201Cansible_become: yes/no\u201D group var will determine if the actions in the playbook need to be run as a different user from the host connection info.).\nVariables not defined on a host will automatically default to the values set in the vars section of the host_group. For example, the below playbook:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'---\n- gather_facts: no\n  hosts: all\n  tasks:\n  - name: Print Hello World\n    debug: \n      msg: "Hello World, my name is {{ person_name}}"\n'})}),"\n",(0,t.jsx)(n.p,{children:"with the below inventory file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"      inventory-file:\n        all:\n          hosts:\n            host1:\n              person_name: John\n            host2:          \n          vars:\n            person_name: Doe\n"})}),"\n",(0,t.jsx)(n.p,{children:"will result in this output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'TASK [Print Hello World] *******************************************************\nok: [host1] => {\n    "msg": "Hello World, my name is John"\n}\nok: [host2] => {\n    "msg": "Hello World, my name is Doe"\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Any section of the \u201Cinventory-file:\u201D can contain dynamic values from dependent grains, from the blueprint\u2019s inputs or from Torque\u2019s parameter storage. For more information, see  ",(0,t.jsx)(n.a,{href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#torque-templating-engine",children:"Torque Templating engine"}),".\n",(0,t.jsx)(n.strong,{children:"Example:"})," Below is an example of a grains section of a blueprint, containing an Ansible grain:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:" grains:\n  hello_world_ansible:\n    kind: ansible\n    spec:\n      source:\n        store: assets\n        path: ansible/hello_world.yaml\n      agent:\n        name: my-torque-agent\n      inventory-file:\n        all:\n          hosts:\n            host1:\n              person_name: John\n            host2:          \n          vars:\n            person_name: Doe\n"})}),"\n",(0,t.jsx)(n.h3,{id:"outputs",children:(0,t.jsx)(n.code,{children:"outputs"})}),"\n",(0,t.jsx)(n.p,{children:"Ansible does not support outputs from playbooks natively so Torque adds this support on top of the ansible capabilities.\nWhy would you need outputs from your ansible grain?\nOutput from the ansible grain can be passed to another grain (ansible or not) or to become one of the blueprint outputs so can be provided to the blueprint consumer (the end user)."}),"\n",(0,t.jsx)(n.p,{children:'For this purpose, we have developed the Torque ansible module "export-torque-outputs".'}),"\n",(0,t.jsx)(n.p,{children:"The module accepts a dictionary of output names and values."}),"\n",(0,t.jsx)(n.p,{children:"Usage example:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Playbook:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"tasks:\n  - name: task1\n      configure_vm:\n      \u2026\n      register: result1\n    \u2026\n  - name: task2\n      do_something_else:\n      \u2026\n      register: result2\n    \n\n - name: Export outputs\n    torque.collections.export_torque_outputs:\n      outputs:\n        output1: \u201C{{ result1 }}\u201D\n        output2: \u201C{{ result2 }}\u201D\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:'The task which runs the "export_torque_outputs" module must be run on localhost.'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Blueprint:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n   configure-vm:\n      kind: ansible\n      spec:\n       ...\n        outputs:\n          - output1\n          - output2  \n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you wish to install the module locally to test it, please run ",(0,t.jsx)(n.code,{children:"ansible-galaxy collection install torque.collections"}),"\nThe module resides in the marketplace : ",(0,t.jsx)(n.a,{href:"https://galaxy.ansible.com/torque/collections",children:"https://galaxy.ansible.com/torque/collections"})]}),"\n",(0,t.jsx)(n.h3,{id:"command-arguments",children:(0,t.jsx)(n.code,{children:"command-arguments"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"command-arguments"})," field allows you to pass additional arguments to the ",(0,t.jsx)(n.code,{children:"ansible-playbook"})," command when executing the Ansible playbook. This gives you flexibility to customize the Ansible run as needed."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"grains:\n  print_hello:\n    kind: ansible\n    spec:\n      source:\n        store: ansible-repo\n        path: ansible/playbook.yaml\n      agent:\n        name: '{{ .inputs.agent }}'\n      command-arguments: \"--skip-tags deploy --force-handlers\"\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will run ",(0,t.jsx)(n.code,{children:"ansible-playbook"})," with the ",(0,t.jsx)(n.code,{children:"--skip-tags deploy --force-handlers"})," flags appended to the command."]}),"\n",(0,t.jsxs)(n.p,{children:["Here's a more complete example showing usage of ",(0,t.jsx)(n.code,{children:"command-arguments"})," along with other Ansible grain configurations:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\ndescription: Run an Ansible playbook with a local connection\n\ninputs:\n  agent:\n    type: agent\n\ngrains:\n  print_hello:\n    kind: ansible\n    spec:\n      source:\n        store: ansible-repo\n        path: ansible/playbook.yaml\n      agent:\n        name: '{{ .inputs.agent }}'\n      command-arguments: \"--skip-tags deploy --version\" \n      env-vars: []\n      inventory-file:\n        localhost:\n          hosts:\n            127.0.0.1:\n              ansible_connection: local\n"})}),"\n",(0,t.jsx)(n.p,{children:"For the Blueprint example above, the directory structure is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"playbook.yaml\nroles/\n    hello/\n        tasks/\n            main.yaml\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"playbook.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"---\n- hosts: localhost\n  roles:\n    - hello\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"roles/hello/tasks/main.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'---\n- name: Print hello\n  debug:\n    msg: "hello"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This will execute the ",(0,t.jsx)(n.code,{children:"hello"}),' role, which will print "hello" to the console.']}),"\n",(0,t.jsx)(n.p,{children:"Note that this is a very simple example, and roles can be much more complex, containing multiple tasks, handlers, variables, and other components. Additionally, roles can be shared across multiple playbooks or even distributed as reusable Ansible roles."}),"\n",(0,t.jsxs)(n.p,{children:["In this blueprint, when executing the ",(0,t.jsx)(n.code,{children:"print_hello"})," Ansible grain, the ",(0,t.jsx)(n.code,{children:"ansible-playbook"})," command will include the ",(0,t.jsx)(n.code,{children:"--skip-tags deploy --version"})," flags specified in the ",(0,t.jsx)(n.code,{children:"command-arguments"})," field."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"command-arguments"})," value can include any valid arguments that could be passed to ",(0,t.jsx)(n.code,{children:"ansible-playbook"}),". This allows customizing things like tags to run/skip, handling behavior, displaying version info, and more."]}),"\n",(0,t.jsx)(n.h3,{id:"scripts",children:(0,t.jsx)(n.code,{children:"scripts"})}),"\n",(0,t.jsx)(n.p,{children:"Torque allows you to run scripts before executing the Ansible playbook. This can be useful for various purposes, such as setting up the environment or performing prerequisite tasks."}),"\n",(0,t.jsxs)(n.p,{children:["To run a script before the Ansible playbook execution, you can define it under the ",(0,t.jsx)(n.code,{children:"scripts"})," section of the Ansible grain. The ",(0,t.jsx)(n.code,{children:"pre-ansible-run"})," key is used to specify the script to be executed."]}),"\n",(0,t.jsx)(n.h4,{id:"use-case-creating-a-vault-password-file",children:"Use Case: Creating a Vault Password File"}),"\n",(0,t.jsx)(n.p,{children:"One common use case is to create a file containing the Ansible Vault password. This password is required when working with encrypted data in Ansible playbooks. Here's an example of how you can pass a token from the parameter store as the Vault password:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec_version: 2\ndescription: Ansible playbook example with pre-ansible-run scripts\ninputs: ...\ngrains:\n  ansible_playbook:\n    kind: ansible\n    spec:\n      source:\n        store: ansible-repo\n        path: ansible/playbook.yml\n      agent: ...\n      command-arguments: \"--vault-password-file ~/.vault_pass.txt\"\n      scripts:\n        pre-ansible-run:\n          source:\n            store: my-script-repo\n            path: scripts/create_vault_file.sh\n          arguments: '{{ .params.vault_pass }}'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"pre-ansible-run"})," script is defined under the ",(0,t.jsx)(n.code,{children:"scripts"})," section. The ",(0,t.jsx)(n.code,{children:"source"})," field specifies the location of the script (in this case, a Git repository named ",(0,t.jsx)(n.code,{children:"my-script-repo"}),"), and the ",(0,t.jsx)(n.code,{children:"path"})," field specifies the relative path to the script within the repository."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"arguments"})," field allows you to pass arguments to the script. In this case, the value of ",(0,t.jsx)(n.code,{children:"{{ .params.vault_pass }}"})," is used, which retrieves the Vault password from the parameter store."]}),"\n",(0,t.jsxs)(n.p,{children:["The script ",(0,t.jsx)(n.code,{children:"create_vault_file.sh"})," should create a file named ",(0,t.jsx)(n.code,{children:".vault_pass.txt"})," in the current working directory and write the Vault password to it. Ansible will then use this file to decrypt the encrypted data in the playbook, as specified by the ",(0,t.jsx)(n.code,{children:"--vault-password-file"})," argument in the ",(0,t.jsx)(n.code,{children:"command-arguments"})," field."]}),"\n",(0,t.jsx)(n.h4,{id:"script-execution-environment",children:"Script Execution Environment"}),"\n",(0,t.jsx)(n.p,{children:"The pre-Ansible run scripts are executed within the same environment as the Ansible playbook itself. This means that any environment variables or files created by the script will be accessible to the Ansible playbook."}),"\n",(0,t.jsx)(n.h4,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The scripts are executed in the order they are defined."}),"\n",(0,t.jsx)(n.li,{children:"If a script fails (non-zero exit code), the Ansible playbook execution will be aborted."}),"\n",(0,t.jsx)(n.li,{children:"Make sure to include any required dependencies or libraries for the scripts within the script repository or the Ansible repository."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By using pre-Ansible run scripts, you can enhance the flexibility and functionality of your Ansible playbooks within the Torque ecosystem."}),"\n",(0,t.jsx)(n.h3,{id:"on-destroy",children:(0,t.jsx)(n.code,{children:"on-destroy"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"on-destroy"})," section allows you to define a cleanup or teardown process that will be executed when the grain is destroyed. This is particularly useful for ensuring that resources created during the grain's lifecycle are properly cleaned up, avoiding resource leaks or unintended costs."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"on-destroy"})," section mirrors the structure of the main Ansible grain configuration, allowing you to specify a separate playbook, inputs, inventory file, and other configurations for the teardown process."]}),"\n",(0,t.jsx)(n.h4,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Cleanup"}),": Ensure that resources created during the grain's execution are properly removed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost Management"}),": Avoid incurring unnecessary costs by cleaning up unused resources."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistency"}),": Maintain a clean and predictable environment by defining explicit teardown steps."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,t.jsxs)(n.p,{children:["Below is an example of a grain with an ",(0,t.jsx)(n.code,{children:"on-destroy"})," section:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"\ninputs:\n  vm-name:\n    type: string\n  agent:\n    type: agent\n\ngrains:\n  vm:\n    kind: ansible\n    spec:\n      source:\n        store: ansible-repo\n        path: vcenter/vm_deploy.yaml\n      agent:\n        name: '{{ .inputs.agent }}'\n      env-vars:\n        - CUSTOM_TOKEN: '{{ .params.token }}'\n      inputs:\n        - name: '{{ .inputs.vm-name }}'\n      command-arguments: \"--tags deploy\"\n      on-destroy:\n        source:\n          store: ansible-repo\n          path: vcenter/vm_destroy.yaml\n        inputs:\n          - name: '{{ .inputs.vm-name }}'\n        command-arguments: \"--tags destroy\"\n        inventory-file:\n          localhost:\n            hosts:\n              127.0.0.1:\n                ansible_connection: local\n        scripts:\n          pre-ansible-run:\n            source:\n              store: scripts\n              path: scripts/run.sh\n"})}),"\n",(0,t.jsx)(n.h4,{id:"explanation-of-the-example",children:"Explanation of the Example"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"source"})}),": Specifies the playbook to be executed during the destroy phase. In this case, it uses the same playbook as the main grain but with different tags."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"inputs"})}),": Inputs specific to the destroy phase, such as variables required for cleanup."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"command-arguments"})}),": Additional arguments passed to the ",(0,t.jsx)(n.code,{children:"ansible-playbook"})," command. Here, the ",(0,t.jsx)(n.code,{children:"--tags destroy"})," argument ensures only the tasks tagged with ",(0,t.jsx)(n.code,{children:"destroy"})," are executed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"inventory-file"})}),": Defines the inventory file for the destroy phase, which can differ from the main execution phase."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"scripts"})}),": Allows running pre-destroy scripts, such as setting up the environment or preparing for teardown."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"on-destroy"})," section is optional but highly recommended for grains that create external resources."]}),"\n",(0,t.jsxs)(n.li,{children:["Ensure that the playbook and inputs used in the ",(0,t.jsx)(n.code,{children:"on-destroy"})," section are designed to handle the cleanup process effectively."]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"on-destroy"})," process fails, it may leave resources in an inconsistent state. Proper error handling and validation are crucial."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By using the ",(0,t.jsx)(n.code,{children:"on-destroy"})," section, you can ensure that your Ansible grains are not only effective during deployment as a configuration management, but also responsible during teardown, maintaining a clean and efficient environment."]})]})}function h(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},4429:function(e,n,s){s.d(n,{R:()=>r,x:()=>o});var i=s(6540);let t={},a=i.createContext(t);function r(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);