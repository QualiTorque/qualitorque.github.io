"use strict";(self.webpackChunktorque=self.webpackChunktorque||[]).push([[3745],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(a),d=r,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||i;return a?n.createElement(h,o(o({ref:t},u),{},{components:a})):n.createElement(h,o({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2835:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:9,title:"The Terraform Grain"},o=void 0,s={unversionedId:"blueprint-designer-guide/blueprints/terraform-grain",id:"blueprint-designer-guide/blueprints/terraform-grain",title:"The Terraform Grain",description:"The Terraform grain is Torque's native support for HashiCorp Terraform modules. Torque allows designers to use Terraform-specific features to easily orchestrate self-developer and community Terraform modules in a standard way and share them with others as building blocks. For a full blueprint yaml example, see the examples in section Create a multi-asset blueprint.",source:"@site/docs/blueprint-designer-guide/blueprints/terraform-grain.md",sourceDirName:"blueprint-designer-guide/blueprints",slug:"/blueprint-designer-guide/blueprints/terraform-grain",permalink:"/blueprint-designer-guide/blueprints/terraform-grain",editUrl:"https://github.com/QualiTorque/torque-docs/tree/master/docs/blueprint-designer-guide/blueprints/terraform-grain.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"The Terraform Grain"},sidebar:"torqueSidebar",previous:{title:"Blueprint YAML Structure",permalink:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure"},next:{title:"The Helm Grain",permalink:"/blueprint-designer-guide/blueprints/helm-grain"}},l={},p=[{value:"Tools and technologies",id:"tools-and-technologies",level:3},{value:"source",id:"source",level:3},{value:"agent",id:"agent",level:3},{value:"authentication",id:"authentication",level:3},{value:"provider-overrides",id:"provider-overrides",level:3},{value:"terraform.tfstate remote backend storage",id:"terraformtfstate-remote-backend-storage",level:3},{value:"version",id:"version",level:3},{value:"inputs",id:"inputs",level:3},{value:"tfvars files as inputs to Terraform grain",id:"tfvars-files-as-inputs-to-terraform-grain",level:3},{value:"tags",id:"tags",level:3},{value:"outputs",id:"outputs",level:3},{value:"scripts",id:"scripts",level:3},{value:"auto-approve flag",id:"auto-approve-flag",level:3},{value:"environment variables",id:"environment-variables",level:3}],u={toc:p},m="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The Terraform grain is Torque's native support for HashiCorp Terraform modules. Torque allows designers to use Terraform-specific features to easily orchestrate self-developer and community Terraform modules in a standard way and share them with others as building blocks. For a full blueprint yaml example, see the examples in section ",(0,r.kt)("a",{parentName:"p",href:"/blueprint-designer-guide/blueprint-quickstart-guide#create-a-multi-asset-blueprint"},"Create a multi-asset blueprint"),"."),(0,r.kt)("p",null,"Note that to deploy Terraform modules, you will need to authenticate Terraform on the Kubernetes cluster. For details, see ",(0,r.kt)("a",{parentName:"p",href:"/torque-agent/service-accounts-for-aws"},"Terraform EKS Authentication"),", ",(0,r.kt)("a",{parentName:"p",href:"/torque-agent/service-accounts-for-azure"},"Terraform AKS Authentication"),", or ",(0,r.kt)("a",{parentName:"p",href:"/torque-agent/service-accounts-for-gcp"},"Terraform GKE Authentication"),"."),(0,r.kt)("h3",{id:"tools-and-technologies"},"Tools and technologies"),(0,r.kt)("p",null,"The following tools and technologies are installed out of the box on our agents in the Kubernetes pods and can be used when writing grain scripts (pre/post, etc.):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"dotnet"),(0,r.kt)("li",{parentName:"ul"},"terraform"),(0,r.kt)("li",{parentName:"ul"},"git"),(0,r.kt)("li",{parentName:"ul"},"python3"),(0,r.kt)("li",{parentName:"ul"},"pip3"),(0,r.kt)("li",{parentName:"ul"},"jq"),(0,r.kt)("li",{parentName:"ul"},"docker-compose"),(0,r.kt)("li",{parentName:"ul"},"curl|- hcl2json"),(0,r.kt)("li",{parentName:"ul"},"awscli"),(0,r.kt)("li",{parentName:"ul"},"kubectl"),(0,r.kt)("li",{parentName:"ul"},"helm"),(0,r.kt)("li",{parentName:"ul"},"opa")),(0,r.kt)("h3",{id:"source"},"source"),(0,r.kt)("p",null,"Please see ",(0,r.kt)("a",{parentName:"p",href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#source"},"the grain source")," for more details."),(0,r.kt)("h3",{id:"agent"},"agent"),(0,r.kt)("p",null,"Please see ",(0,r.kt)("a",{parentName:"p",href:"/blueprint-designer-guide/blueprints/blueprints-yaml-structure#agent"},"the grain agent")," for more details."),(0,r.kt)("h3",{id:"authentication"},"authentication"),(0,r.kt)("p",null,"To authenticate with AWS and deploy the terraform module, Torque will try to use the default service account configured for the selected agent. You can also supply different credentials in the  grain's ",(0,r.kt)("inlineCode",{parentName:"p"},"authentication")," section. This is done by referencing a ",(0,r.kt)("a",{parentName:"p",href:"/admin-guide/credentials"},"credential")," that contains these authentication details. There are two ways to specify the credential, literally by name or using an input:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: infra \n        path: terraform/rds\n      authentication:\n        - credential_name or {{.inputs.credentials_input_name}} \n")),(0,r.kt)("h3",{id:"provider-overrides"},"provider-overrides"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"provider-overrides"),' block allows you to dynamically inject provider blocks with custom attributes to Terraform grains. This is useful when you need to make modules "runnable" or "testable" in different cloud environments.'),(0,r.kt)("p",null,"To use provider overrides, add a ",(0,r.kt)("inlineCode",{parentName:"p"},"provider-overrides")," block to the Terraform grain spec:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'grains:\n  database:\n    kind: terraform\n    spec:\n      source: ..\n      provider-overrides:\n        - name: aws # in case no provider block is defined in the tf configuration\n          source: hashicorp/aws\n          version: ~>5.0.0 \n          attributes:\n            region: us-east-1\n            assume_role: # the mounted service-account should have permissions to assume role\n              role_arn: "arn:aws:iam::{{ .inputs.target-account }}:role/role-name"\n        - name: aws\n          source: hashicorp/aws\n          version: ~>5.0.0 # Optional \n          attributes:\n            alias: ue2\n            region: us-east-2\n      \n      source: ...\n      agent: ...\n      inputs: ...\n      outputs: ...\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"provider-overrides")," block is a list where each item has:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),": A unique name for the provider"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"source"),": The source location for the provider (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"hashicorp/aws"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"version")," (optional): The version constraint for the provider"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attributes"),": Key/value attributes to set on the provider block")),(0,r.kt)("p",null,"This will generate the following Terraform code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-hcl"},'terraform {\n  required_providers {\n    aws = {\n      source = "hashicorp/aws"\n      version = "~>5.0.0" \n    }   \n  }\n}\n\nprovider {\n "aws": [{\n    region      = "us-east-1"\n    assume_role {\n      role_arn = "arn:aws:iam::{{ .inputs.target-account }}:role/role-name"\n    }\n  },\n  {\n    alias       = "ue2" \n    region      = "us-east-2"\n  }]\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"attributes")," map allows setting any attributes on the generated provider blocks. Note that there is no schema validation on these attributes."),(0,r.kt)("p",null,"Liquid templating is supported in the ",(0,r.kt)("inlineCode",{parentName:"p"},"attributes")," values, allowing blueprint inputs to be referenced like ",(0,r.kt)("inlineCode",{parentName:"p"},"{{ .inputs.target-account }}"),"."),(0,r.kt)("h3",{id:"terraformtfstate-remote-backend-storage"},"terraform.tfstate remote backend storage"),(0,r.kt)("p",null,"When launching the environment, Torque creates a tfstate file for each Terraform grain in the blueprint. By default, the file is saved locally on the PVC of the grain runner (volume for Docker agents). However, as the TF state file may contain sensitive information, Torque allows you to optionally choose to save the file in your own remote backend storage. Torque supports the following remote backends: ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://developer.hashicorp.com/terraform/language/settings/backends/s3"},"S3")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://developer.hashicorp.com/terraform/language/settings/backends/gcs"},"gcs")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://developer.hashicorp.com/terraform/language/settings/backends/azurerm"},"azurerm")),", and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://developer.hashicorp.com/terraform/language/settings/backends/http"},"http")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Prerequisites:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The remote backend must already exist. Torque will not create the remote backend if it doesn't exist."),(0,r.kt)("li",{parentName:"ul"},"Role Arn or service account defined in the ",(0,r.kt)("inlineCode",{parentName:"li"},"authentication")," must have access permissions to the remote backend.")),(0,r.kt)("p",null,"The remote backend is specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"backend")," section of the grain. Based on the blueprint YAML definition, Torque will create an override file that contains the remote backend configurations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'grains:\n  database:\n    kind: terraform\n    spec:\n      ...\n      backend:\n        type: "s3"\n        bucket: "my-bucket-name"\n        region: "us-east-1"\n        key-prefix: "folder1/folder2"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Properties"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"type"),": s3, azurerm, gcs, http, remote"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"bucket"),": Mandatory for s3 and gcs"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"region"),": Mandatory for S3"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"resource-group-name")," : Mandatory for azurerm"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"storage-account-name"),": Mandatory for azurerm"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"container-name"),": Mandatory for azurerm"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"base-address"),": Mandatory for http"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"key-prefix"),": Optional. tfstate file path in the remote storage. Relevant for s3, azurerm, gcs. ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"S3, Azure Blobs & GCS have a key name limit of 1024 ascii chars")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"S3"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'backend:\n  type: "s3"\n  bucket: "my-bucket-name"\n  region: "us-east-1"\n  key-prefix: folder1/folder2"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"azurerm"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'backend:\n  type: "azurerm"\n  resource-group-name: "my_rg"\n  storage-account-name: "terraform123abc"\n  container-name: "terraform-state"\n  key-prefix: folder1/folder2"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"gcs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'backend:\n  type: "gcs"\n  bucket: "my-bucket-name"\n  key-prefix: "folder1/folder2"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"http"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'backend:\n  type: "http"\n  base-address: "http://myrest.api.com/foo"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"remote"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  remote:\n    kind: 'terraform'\n    spec:\n      source:\n        store: 'common'\n        path: 'terraform/rds'\n      backend:\n        type: 'remote'\n        hostname: 'app.terraform.io'\n        token: '{{ params.my_token }}'\n        organization: 'my_org'\n        workspaces:\n          - name: 'my_workspace' # IMPORTANT: only one (name or prefix) is needed in each workspace element\n            prefix: 'my_prefix'\n      agent:\n        name: '{{ .inputs.agent }}'\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"remote")," token options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("inlineCode",{parentName:"li"},"token")," filed in the ",(0,r.kt)("inlineCode",{parentName:"li"},"remote")," backend definition is best practice."),(0,r.kt)("li",{parentName:"ul"},'"TF',(0,r.kt)("em",{parentName:"li"},'TOKEN" ',(0,r.kt)("inlineCode",{parentName:"em"},"env_var"),", followed by the hostname (with replace of '.' in '"),"') is an alternative way to provide a token.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For example for the host 'app.terraform.io', the env-var name should be ",(0,r.kt)("inlineCode",{parentName:"li"},"TF_TOKEN_app_terraform_io"))))),(0,r.kt)("p",null,"Note:"),(0,r.kt)("p",null,'Torque uses a "1 to many" model, meaning that one blueprint definition is used to launch many standalone environments. When using a backend for Terraform grains, it is important to ensure that each live instance of the grain has its own unique tfstate file, so Torque will auto-generate the tfstate file name. '),(0,r.kt)("p",null,"For s3, gcs, azurerm backends, the tfstate file location will be: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Format when the \u201ckey-prefix\u201d is not defined: "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml\u201c"},"torque-remote-state/{environmentId}_{grainName}.tfstate\u201c\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Format when \u201ckey-prefix\u201d defined in the blueprint:\nUsing the optional \u201ckey-prefix\u201d property the blueprint designer can choose the folder where the tfstate file will be located. "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"\u201c{key-prefix}/{environmentId}_{grainName}.tfstate \n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For http backend the tfstate file address will be: "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"\u201c{base-address}/{environmentId}_{grainName}\u201d \n")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cleaning up the tfstate file when the Terraform grain is destroyed:")),(0,r.kt)("p",null,"When destroying a Terraform environment, Terraform does not delete the tfstate file but rather leaves behind an empty file. To clean up the leftovers, set a file retention policy on the remote storage to ensure the removal of files that have not been recently accessed. Since Torque runs drift detection on a 1-hour schedule, the tfstate file will be considered as \u201caccessed\u201d by the remote storage when running drift detection. And when the Torque environment ends, the tfstate file will not be \u201caccessed\u201d anymore by Torque. "),(0,r.kt)("h3",{id:"version"},"version"),(0,r.kt)("p",null,"Torque provides the flexibility to choose a specific Terraform version with which the Terraform module will be deployed (minimum supported version is 0.14, last version supported is 1.5.5). Otherwise, you can use the ",(0,r.kt)("a",{parentName:"p",href:"/blueprint-designer-guide/blueprints/custom-grain"},"custom-grain option"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  hello_world:\n    kind: terraform\n    spec:\n      version: 1.5.5\n      source:\n        store: terraform\n        path: hello\n      ...\n")),(0,r.kt)("h3",{id:"inputs"},"inputs"),(0,r.kt)("p",null,"Similar to blueprint inputs, the Terraform grain input allows you to reuse the same Terraform module in different ways. Inputs provided to the Terraform grain are used when launching the Terraform module. Terraform grain inputs should be listed in the order defined in the module's variables.tf file. We recommend using Torque's auto-discovery capability to quickly model your Terraform modules within Torque including all defined inputs."),(0,r.kt)("p",null,"Every value that goes to the Terraform grain's input is interpreted as a json token. So you can pass any valid value by json: number, list, dictionary, boolean, string , etc.\nFor details, check out this Terraform Docs section ",(0,r.kt)("a",{parentName:"p",href:"https://www.terraform.io/language/values/variables#variable-definitions-tfvars-files"},"Variable Definitions (.tfvars) Files")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: infra \n        path: terraform/rds\n      authentication:\n        - ...        \n      ...\n      inputs:\n        - database_size: \'{{ .inputs.db_size }}\' \n        - database_name: \'{{ .inputs.db_name }}\' \n        - input_number: 6\n        - input_string: \'{" this is my input string "}\'\n        - input_list_strings: \'["a","b","c"]\'\n        - input_map_strings: \'{ "key1":"val1", "key2":"val2" }\'\n        - input_object: \'{ "key1":val1, "key2":4 }\'\n')),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},'Note that in the above example, some blueprint inputs are used as the values of the Terraform grain inputs, so the environment\'s owner is able to choose the db_size and db_name required for his need. The information provided by the user will be passed to Terraform and affect the deployment process. The blueprint input type is always "string". the actual parsing of the json type will be done automatically.'))),(0,r.kt)("p",null,"Note that invalid tokens will be parsed as strings. Keep in mind that json strings require double quotes, so ",(0,r.kt)("inlineCode",{parentName:"p"},'"my value')," is a string but ",(0,r.kt)("inlineCode",{parentName:"p"},"my value")," is not a valid json value and therefore will also be passed as a string. As such, the following values will all be passed as strings: ",(0,r.kt)("inlineCode",{parentName:"p"},'"my value"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},"my value"),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"[1,2,3]"')),(0,r.kt)("h3",{id:"tfvars-files-as-inputs-to-terraform-grain"},"tfvars files as inputs to Terraform grain"),(0,r.kt)("p",null,'In Terraform, a tfvars file (short for "Terraform variables file") is a plain text file that contains a set of key-value pairs representing values for Terraform variables. Torque supports referencing tfvars files as inputs to the terraform grain, with the following syntax:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: infra \n        path: terraform/rds\n      authentication:\n        - ...        \n      ...\n      inputs:\n        ...\n      tfvars-files:\n      - source:\n          store: <> \n          path: <>\n      - source:\n          store: <>\n          path: <>\n\n")),(0,r.kt)("h3",{id:"tags"},"tags"),(0,r.kt)("p",null,"Whenever a Terraform grain is launched, all resources created during the deployment process will be automatically tagged with Torque's system tags, built-in tags and custom tags. For details, see ",(0,r.kt)("a",{parentName:"p",href:"/governance/tags"},"Tags"),".\nSometimes, you need to disable tagging for all or specific resources.\nTo disable ",(0,r.kt)("em",{parentName:"p"},"all")," resources in a specific grain use the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  database:\n    kind: terraform\n    spec:\n      tags:\n        auto-tag: false\n")),(0,r.kt)("p",null,"To disable ",(0,r.kt)("em",{parentName:"p"},"specific")," resources in a specific grain use the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  database:\n    kind: terraform\n    spec:\n      tags:\n        disable-tags-for:\n        - aws_s3_bucket_object ## the terraform resource type\n")),(0,r.kt)("h3",{id:"outputs"},"outputs"),(0,r.kt)("p",null,"Output are values generated by Terraform during the deployment process. Outputs should be defined in the outputs.tf file located in the Terraform module folder. We recommend using Torque's auto-discovery capability to quickly model your Terraform modules within Torque including it's defined outputs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  database:\n    kind: terraform\n    spec:\n      source:\n        store: my-repo \n        path: my-asset     \n      ...\n      outputs:\n        - agent_name\n        - connection_string\n")),(0,r.kt)("h3",{id:"scripts"},"scripts"),(0,r.kt)("p",null,"Torque provides the ability to execute custom code before the executing the Terraform module init and before the Terraform destroy process. Scripts allows to run CLI commands to make sure authentication and requirements are set prior to the Terraform execution at the environment's initialization and destroy process."),(0,r.kt)("p",null,"The available script hooks are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pre-tf-init: The script will run before the command ",(0,r.kt)("inlineCode",{parentName:"li"},"terraform init")),(0,r.kt)("li",{parentName:"ul"},"post-tf-plan: The script will run after the command ",(0,r.kt)("inlineCode",{parentName:"li"},"terraform plan")," "),(0,r.kt)("li",{parentName:"ul"},"pre-tf-destroy: The script will run before the command ",(0,r.kt)("inlineCode",{parentName:"li"},"terraform destroy"),"\nIn the below example, authentication script is used to assume role to another AWS account prior to deploying workload into that account.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  amazon_emr:\n    kind: terraform\n    spec:\n    ...\n      source:\n        store: tf-repo\n        path: .\n      authentication:\n        - aws-auth        \n      scripts: \n        pre-tf-init:\n          source:\n            store: tf-repo\n            path : scripts/authenticate.sh\n          arguments: '{{.inputs.ACCOUNT_ID}}'\n        post-tf-plan:\n          source:\n            store: tf-repo\n            path : scripts/verify-plan.sh\n          arguments: '{{.inputs.ID2}'          \n        pre-tf-destroy:\n          source:\n            store: tf-repo\n            path : scripts/authenticate.sh\n          arguments: \"{{.inputs.ACCOUNT_ID}} {{.inputs.ID2}} 3\"\n")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Note that scripts should be stored next to your IaC code to be used under the scripts section."))),(0,r.kt)("p",null,"When writing the scripts, you can take advantage of the following out of the box environment variables provided by Torque:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TORQUE_TF_EXECUTABLE")," - the terraform executable file name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TORQUE_TF_MODULE_PATH")," - the path to the terraform executable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TORQUE_TF_PLAN_PATH")," - path to the results of the terraform plan command. This is very useful to be used in a post-tf-plan script for verification of the plan."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TORQUE_TF_PLAN_JSON_PATH")," - path to the results of the terraform plan command in json format. ")),(0,r.kt)("p",null,"For example, the script can contain the following :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$TORQUE_TF_EXECUTABLE -chdir=$TORQUE_TF_MODULE_PATH state rm $1\n")),(0,r.kt)("p",null,"Or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$TORQUE_TF_EXECUTABLE -chdir=$TORQUE_TF_MODULE_PATH state rm <hardcoded_resource>\n")),(0,r.kt)("p",null,"Here is another example which shows how to use the plan output in a post-tf-plan script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'\n## validate-no-new-resources.sh\n\nif grep -q \'Plan: [1-9][0-9]* to add, 0 to change, 0 to destroy\' "$TORQUE_TF_PLAN_JSON_PATH"; then\n  echo "Error: The plan indicates new resources"\n  exit 1\nelse\n  echo "Success: No new resources added."\n  exit 0\nfi\n\n')),(0,r.kt)("h3",{id:"auto-approve-flag"},"auto-approve flag"),(0,r.kt)("p",null,'The "auto-approve" flag in Terraform is used to automatically approve and apply changes without requiring manual confirmation. It is helpful in automation workflows or scripts where user interaction is not feasible, allowing for unattended execution of Terraform commands without the need for explicit approval during the apply phase. By default, Torque will apply the terraform module with auto-approval.\nHowever, you might specifically want to ensure that critical or potentially destructive changes are reviewed and approved by a user before being applied. This adds an extra layer of safety, especially in scenarios where unintended consequences could result from applying infrastructure changes. It provides an opportunity to carefully inspect the proposed changes before confirming their execution.\nTo do that, you can set the auto-approve flag in the terraform grain spec to false (default will be true):'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"grains:\n  my-tf-grain:\n    kind: terraform\n    spec:\n    ...\n      auto-approve: false\n")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Initial provisioning will always be automatically approved. Setting auto-approve to false will only affect subsequent updates. "))),(0,r.kt)("h3",{id:"environment-variables"},"environment variables"),(0,r.kt)("p",null,"The environment variables declared in the terraform grain will be available during the grain deployment as well as the grain destroy phase."),(0,r.kt)("p",null,"In this example, terraform is using a backend of type ",(0,r.kt)("a",{parentName:"p",href:"https://developer.hashicorp.com/terraform/language/settings/backends/remote"},"remote")," with a custom host that requires a custom certificate."),(0,r.kt)("p",null,"You can mount the Terraform Runner, a Kubernetes secret containing the certificate file(s) to a directory in the container, and the certificate(s) will be available for use ",(0,r.kt)("strong",{parentName:"p"},"without"),' running any additional commands (like "sudo update-ca-certificates")'),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},(0,r.kt)("em",{parentName:"p"},"Learn how to mount secrets to a runner - ",(0,r.kt)("a",{parentName:"em",href:"/torque-agent/advanced-settings#secret-mount"},"Agent Advanced Settings")," ")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Environment variables usage example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"spec_version: 2\ndescription: Passing environment variables to Terraform and using scripts before tf-init\n\ninputs: ...\noutputs: ...\n\ngrains:\n  provision-s3-bucket:\n    kind: terraform\n    spec:  \n      source:\n        store: terraform-mono-repo\n        path: aws/s3-bucket\n      scripts:\n        pre-tf-init: \n          source:\n            store: scripts-repo\n            path : scripts/gen-custom-remote-backend.sh\n          arguments: '{{ .inputs.org }} {{ .inputs.workspace }}'\n      agent: ...\n      inputs: ...\n      outputs: ...\n      \n      # The environment variables declared in this section will be available \n      #  during the grain deployment as well as the grain destroy phase\n      env-vars: \n        - SSL_CERT_FILE: /etc/tls-certs/custom-cert.crt # This is a custom SSL cert file\n        - CUSTOM_TOKEN: '{{ .params.token }}'\n\n")))}c.isMDXComponent=!0}}]);